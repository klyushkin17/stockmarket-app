package com.plcoding.stockmarketapp

/*
В CleanArchitecture проект разделяется на три основных уровня: data, domain, presentation
data - уровень, в котором прописаны вся логика, связанная с данными: Retrofit, Room, CSVParsing
и т.д.
domain - уровень, в котором прописана бизнесс логика. Так же данный уровень является связующим
звеном между data и presentation уровнями, что значит, что presentation не имеет прямого доступа
к data и наоборот.
presentation - все, что показывается на экране: kt файлы и ViewModel.

Data:
--Retrofit--
ResponseBody - тип, который возвращается при получении и скачивании данных из API с помощью
Retrofit.

Для того, чтобы presentation layer не имел доступа к объектам уровня data. Мы создаем
дубликаты сущностей Room и dto в уровне model, причем данные копии являются просто data class
без каких-либо аннотаций. Этот принцип отвечает Clear Architecture
и позволяет свободно модифицировать код в data не привнося никаких изменений в presentation layer

Специально для цели, которая указана выше мы создали директорию mapper, в которой прописана логика того
как переводить сущности Room и dto в data class из domain слоя

dao - data access object - класс, в котором описывается логика взаимодействия с локальной базой данных
(функции доступа к ней, изменения и удаления)

Класс StockDatabase необъодим для создании Room базы данных
Для того, чтобы Room могла воспользоваться нашим классом и создать под копотом базу данных
и dao мы помечаем класс и переменную, как абстрактные

При создании repository мы так же придерживаемся принципа ClearArchitecture и SOLID, что предписывает
разделить реализацию репозитория и его интерфейс. интерфейс необходим для доступа к функциям
репозитория через presentation уровень, а сама реализоация данных функций будет
храниться Impl классе

Для проверки ответа из API был создан generic sealed class Repository, в котором прописаны такие классы
как Success, Error, Loading. В дальнейшем наши функции из Repository будут возвращать класс Resource, который
позволит нам проверить ответ на наличие ошибок

CSV парсеры так же отвечают принципу SOLID и Clean Architecture, так как имеют общий интерфейс
CSVParser, от которого зависят CompanyListingsParser и IntradayInfoParser

Класс CompanyListringsParser предназначен для перевод InputStream в вид List<CompanyListring>
Это делается с помощью объекта типа CSVReader и его бработки через .map в потоке Dispather.IO

В дирректории presentation для каждого экрана создается 4 файла: Screen, ViewModel, State, Event
Screen: разметка на Jetpack Compose
ViewModel: логика экрана
State: переменные олицетворяющие состояния экрана

В функции getCompanyListrings из ViewModel используется функция .copy для обновления данных из State,
благодаря чему мы можем оставлять поля с модификатором val

Для перемещения между экранами было использована библиотека Compose Destinaton Library

Для передачи объектам готовых зависимостей был использован DaggerHilt. Для его работы необходимо:
1) Создать Application класс, нашем случае это StockApplication
2) Объявить данный класс в манифесте
3) Создать класс Module для описания dependency injectin
4) Прописать аннотацию @AndroidEntryPoint для MainActivity

В данном проекте были созданы два файла типа Module.
В первом описываются методы для внедрения Room и Retrofit объектов, при этом используются
функции с аннотацией @Provides
Во втором же прописаны методы связывающие интерфейсы с их Implementation классами
При этом функции явялются абстрактными и помечаются аннотацией @Binds

*/
